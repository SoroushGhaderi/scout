"""FotMob API HTTP client with automatic x-mas token generation.

How FotMob authentication works:
  1. Every API request requires an `x-mas` header — a base64-encoded, URL-specific,
     time-limited, signed token generated by FotMob's JavaScript:
       body  = {"url": path_with_qs, "code": timestamp_ms, "foo": "production:<hash>"}
       sig   = MD5(JSON.stringify(body) + THREE_LIONS_LYRICS).upper()
       token = base64(JSON.stringify({body, signature: sig}))
     The signing constants (foo hash and lyrics) are embedded in FotMob's webpack
     bundle and extracted on first use via a short-lived Playwright session.

     2. The `matchDetails` endpoint also requires a valid `turnstile_verified` cookie
     (Cloudflare Turnstile, expires every hour).  This is read automatically from
     the user's Chrome browser cookie store via `browser-cookie3`.  When Chrome
     cookies are unavailable (e.g. in Docker), the class falls back to credentials
     stored in `credentials.json` (mounted via Docker volume).

All HTTP requests are made with `curl_cffi` which impersonates Chrome's TLS
fingerprint, bypassing Cloudflare's TLS-based bot detection.
"""

import json
import time
import hashlib
import base64
import asyncio
from typing import Optional, Dict, Any

from ...utils.logging_utils import get_logger


# ---------------------------------------------------------------------------
# Signing constants extracted 2026-02-18 — update when FotMob redeploys.
# These are refreshed automatically on startup via Playwright; this serves
# as a hard-coded fallback so the scraper can still run if the live page is
# temporarily unreachable.
# ---------------------------------------------------------------------------
_FALLBACK_FOO_HASH = "b7d7a67fdaf7133d2d86e74f10192829827d674c"

_FALLBACK_H_LYRICS = (
    "[Spoken Intro: Alan Hansen & Trevor Brooking]\n"
    "I think it's bad news for the English game\n"
    "We're not creative enough, and we're not positive enough\n"
    "\n"
    "[Refrain: Ian Broudie & Jimmy Hill]\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home (We'll go on getting bad results)\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "\n"
    "[Verse 1: Frank Skinner]\n"
    "Everyone seems to know the score, they've seen it all before\n"
    "They just know, they're so sure\n"
    "That England's gonna throw it away, gonna blow it away\n"
    "But I know they can play, 'cause I remember\n"
    "\n"
    "[Chorus: All]\n"
    "Three lions on a shirt\n"
    "Jules Rimet still gleaming\n"
    "Thirty years of hurt\n"
    "Never stopped me dreaming\n"
    "\n"
    "[Verse 2: David Baddiel]\n"
    "So many jokes, so many sneers\n"
    "But all those \"Oh, so near\"s wear you down through the years\n"
    "But I still see that tackle by Moore and when Lineker scored\n"
    "Bobby belting the ball, and Nobby dancing\n"
    "\n"
    "[Chorus: All]\n"
    "Three lions on a shirt\n"
    "Jules Rimet still gleaming\n"
    "Thirty years of hurt\n"
    "Never stopped me dreaming\n"
    "\n"
    "[Bridge]\n"
    "England have done it, in the last minute of extra time!\n"
    "What a save, Gordon Banks!\n"
    "Good old England, England that couldn't play football!\n"
    "England have got it in the bag!\n"
    "I know that was then, but it could be again\n"
    "\n"
    "[Refrain: Ian Broudie]\n"
    "It's coming home, it's coming\n"
    "Football's coming home\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "(England have done it!)\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "It's coming home, it's coming home, it's coming\n"
    "Football's coming home\n"
    "[Chorus: All]\n"
    "(It's coming home) Three lions on a shirt\n"
    "(It's coming home, it's coming) Jules Rimet still gleaming\n"
    "(Football's coming home\n"
    "It's coming home) Thirty years of hurt\n"
    "(It's coming home, it's coming) Never stopped me dreaming\n"
    "(Football's coming home\n"
    "It's coming home) Three lions on a shirt\n"
    "(It's coming home, it's coming) Jules Rimet still gleaming\n"
    "(Football's coming home\n"
    "It's coming home) Thirty years of hurt\n"
    "(It's coming home, it's coming) Never stopped me dreaming\n"
    "(Football's coming home\n"
    "It's coming home) Three lions on a shirt\n"
    "(It's coming home, it's coming) Jules Rimet still gleaming\n"
    "(Football's coming home\n"
    "It's coming home) Thirty years of hurt\n"
    "(It's coming home, it's coming) Never stopped me dreaming\n"
    "(Football's coming home)"
)


class PlaywrightFetcher:
    """
    FotMob API HTTP client.

    Generates x-mas tokens in Python (no persistent browser) and makes all
    HTTP requests via curl_cffi with Chrome TLS impersonation.  Cookies are
    sourced from the user's Chrome browser (via browser-cookie3) so the
    Cloudflare Turnstile cookie stays fresh automatically.
    """

    FOTMOB_BASE = "https://www.fotmob.com"
    TURNSTILE_EXPIRY_SECONDS = 3600
    SIGNING_PARAMS_TTL = 86_400  # refresh once per day

    def __init__(self, config):
        self.config = config
        self.logger = get_logger()

        self._foo_hash: Optional[str] = None
        self._h_lyrics: Optional[str] = None
        self._signing_params_ts: float = 0.0

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def initialize(self):
        self._ensure_signing_params()

    def fetch_json(
        self,
        url: str,
        params: Optional[Dict[str, Any]] = None,
    ) -> Optional[Dict[str, Any]]:
        """Make an authenticated GET request and return the parsed JSON body."""
        self._ensure_signing_params()

        api_path = "/api/data/" + url.split("/api/data/")[-1]
        if params:
            qs = "&".join(f"{k}={v}" for k, v in params.items())
            url_path = f"{api_path}?{qs}"
        else:
            url_path = api_path

        full_url = f"{self.FOTMOB_BASE}{url_path}"
        xmas = self._generate_xmas(url_path)
        cookies = self._get_cookies()

        headers = {
            "User-Agent": self.config.api.user_agent,
            "Referer": f"{self.FOTMOB_BASE}/",
            "accept": "*/*",
            "accept-language": "en-US,en;q=0.9",
            "sec-ch-ua": '"Not(A:Brand";v="8", "Chromium";v="144", "Google Chrome";v="144"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"macOS"',
            "x-mas": xmas,
        }

        self.logger.debug(f"GET {url_path}")

        try:
            from curl_cffi import requests as curl_requests

            resp = curl_requests.get(
                full_url,
                headers=headers,
                cookies=cookies,
                impersonate="chrome131",
                timeout=30,
            )
            if resp.status_code == 200:
                return resp.json()
            self.logger.error(
                f"Request failed {resp.status_code}: {url_path} — {resp.text[:200]}"
            )
            return None
        except ImportError:
            self.logger.error(
                "curl_cffi is not installed. Fix: pip install curl_cffi"
            )
            return None
        except Exception as exc:
            self.logger.error(f"Request error for {url_path}: {exc}")
            return None

    def close(self):
        pass

    # ------------------------------------------------------------------
    # x-mas token generation
    # ------------------------------------------------------------------

    def _generate_xmas(self, url_path: str) -> str:
        code = int(time.time() * 1000)
        body = {
            "url": url_path,
            "code": code,
            "foo": f"production:{self._foo_hash}",
        }
        body_json = json.dumps(body, separators=(",", ":"))
        sig = hashlib.md5(
            (body_json + self._h_lyrics).encode("utf-8")
        ).hexdigest().upper()
        token = {"body": body, "signature": sig}
        return base64.b64encode(
            json.dumps(token, separators=(",", ":")).encode("utf-8")
        ).decode("ascii")

    def _ensure_signing_params(self):
        """Keep signing params fresh; extract from the live page once per day."""
        if (
            self._foo_hash
            and (time.time() - self._signing_params_ts) < self.SIGNING_PARAMS_TTL
        ):
            return

        try:
            params = self._extract_signing_params_via_playwright()
            self._foo_hash = params["foo"]
            self._h_lyrics = params["h"]
            self._signing_params_ts = time.time()
            self.logger.info(
                f"x-mas signing params refreshed (foo={self._foo_hash[:12]}…)"
            )
        except Exception as exc:
            if self._foo_hash:
                self.logger.warning(
                    f"Could not refresh signing params ({exc}); using cached values"
                )
            else:
                self.logger.warning(
                    f"Could not extract signing params ({exc}); using built-in fallback"
                )
                self._foo_hash = _FALLBACK_FOO_HASH
                self._h_lyrics = _FALLBACK_H_LYRICS

    def _extract_signing_params_via_playwright(self) -> Dict[str, str]:
        """Load fotmob.com briefly with Playwright to extract the signing params."""
        try:
            from playwright.async_api import async_playwright
        except ImportError as exc:
            raise ImportError(
                "playwright is not installed — cannot extract signing params.\n"
                "Fix: pip install playwright && playwright install chromium"
            ) from exc

        async def _run():
            async with async_playwright() as pw:
                browser = await pw.chromium.launch(
                    headless=True,
                    args=["--no-sandbox", "--disable-setuid-sandbox"],
                )
                page = await browser.new_page()
                await page.goto(
                    self.FOTMOB_BASE,
                    wait_until="domcontentloaded",
                    timeout=30_000,
                )
                await page.wait_for_timeout(3_000)
                result = await page.evaluate(
                    """
                    () => {
                        for (const chunk of (window.webpackChunk_N_E || [])) {
                            const mm = chunk[1];
                            if (!mm) continue;
                            for (const [, factory] of Object.entries(mm)) {
                                const code = factory.toString();
                                if (code.includes('"x-mas"')) {
                                    const fm = code.match(/"production:([a-f0-9]{40})"/);
                                    const hi = code.indexOf('h=`') + 3;
                                    return {
                                        foo: fm ? fm[1] : null,
                                        h: code.substring(hi, code.indexOf('`', hi))
                                    };
                                }
                            }
                        }
                        return null;
                    }
                    """
                )
                await browser.close()
                return result

        result = asyncio.run(_run())
        if not result or not result.get("foo") or not result.get("h"):
            raise ValueError("Could not find signing params in FotMob webpack")
        return result

    # ------------------------------------------------------------------
    # Cookie management
    # ------------------------------------------------------------------

    def _get_cookies(self) -> Dict[str, str]:
        """
        Return a cookie dict for fotmob.com requests.

        Strategy:
        - We need two things: (a) a valid `turnstile_verified` cookie and
          (b) any other session cookies.
        - Chrome cookies (via browser-cookie3) are the freshest source for
          both, but turnstile_verified expires every hour and may be absent.
        - Stored credentials (credentials.json) are the fallback for
          turnstile_verified when Chrome doesn't have a valid one.
        - Final result = Chrome cookies (if available) with the best available
          turnstile_verified injected on top.
        """
        chrome_cookies = self._try_read_chrome_cookies()
        stored_cookies = self._get_stored_credentials_cookies()

        # Determine the best turnstile_verified value
        tv_chrome = chrome_cookies.get("turnstile_verified", "") if chrome_cookies else ""
        tv_stored = stored_cookies.get("turnstile_verified", "") if stored_cookies else ""

        tv_chrome_valid = self._is_turnstile_valid(tv_chrome)
        tv_stored_valid = self._is_turnstile_valid(tv_stored)

        # Build the base cookie dict
        if chrome_cookies:
            base = dict(chrome_cookies)
            source = "Chrome"
        elif stored_cookies:
            base = dict(stored_cookies)
            source = "stored credentials"
        else:
            self.logger.warning("No cookies available — requests may be blocked by Cloudflare")
            return {}

        # Inject the best turnstile_verified
        if tv_chrome_valid:
            base["turnstile_verified"] = tv_chrome
            self.logger.info(f"Using {source} cookies with valid Chrome Turnstile")
        elif tv_stored_valid:
            base["turnstile_verified"] = tv_stored
            self.logger.info(
                f"Using {source} cookies + stored Turnstile "
                f"(Chrome Turnstile {'expired' if tv_chrome else 'absent'})"
            )
        else:
            self.logger.warning(
                "No valid turnstile_verified found in Chrome or stored credentials. "
                "Visit fotmob.com in Chrome to refresh it, then run refresh_turnstile.py."
            )

        return base

    def _is_turnstile_valid(self, tv: str) -> bool:
        """
        Return True if the turnstile_verified cookie value looks valid.

        The cookie is a JWT-like string: <header>.<timestamp_ms>.<sig>
        We check the timestamp part if present; otherwise we accept any
        non-empty value (FotMob may change the format).
        """
        if not tv:
            return False
        parts = tv.split(".")
        if len(parts) == 3:
            try:
                age = int(time.time()) - int(parts[1])
                return age < self.TURNSTILE_EXPIRY_SECONDS
            except (ValueError, OverflowError):
                pass
        # Unknown format — accept it optimistically
        return True

    def _try_read_chrome_cookies(self) -> Optional[Dict[str, str]]:
        """Try to read fotmob.com cookies from the local Chrome profile.

        Tries both '.fotmob.com' (subdomain-wildcard cookies) and 'fotmob.com'
        (host-specific cookies) because Cloudflare may store turnstile_verified
        under either domain key depending on the browser version.
        """
        try:
            import browser_cookie3

            cookies: Dict[str, str] = {}
            for domain in (".fotmob.com", "fotmob.com", "www.fotmob.com"):
                try:
                    cj = browser_cookie3.chrome(domain_name=domain)
                    cookies.update({c.name: c.value for c in cj})
                except Exception:
                    pass

            if cookies:
                self.logger.debug(
                    f"browser-cookie3: {len(cookies)} fotmob cookie(s) from Chrome "
                    f"(turnstile_verified={'yes' if 'turnstile_verified' in cookies else 'no'})"
                )
                return cookies
        except Exception as exc:
            self.logger.debug(f"browser-cookie3 unavailable: {exc}")
        return None

    def _get_stored_credentials_cookies(self) -> Dict[str, str]:
        """Read cookies from fotmob_credentials.py (hot-reloaded on every call)."""
        cookies = self._read_credentials_file_cookies()
        return cookies if cookies else {}

    def _read_credentials_file_cookies(self) -> Optional[Dict[str, str]]:
        """Directly read credentials.json from disk (bypasses startup cache)."""
        try:
            import json
            from pathlib import Path

            creds_path = Path(__file__).parent.parent.parent.parent / "credentials.json"
            if not creds_path.exists():
                self.logger.warning(f"credentials.json not found at {creds_path}")
                return None

            with open(creds_path, "r") as f:
                data = json.load(f)
                cookies = data.get("cookies", {})
                self.logger.debug(
                    f"credentials.json (live): {len(cookies)} cookie(s) "
                    f"(turnstile_verified={'yes' if 'turnstile_verified' in cookies else 'no'})"
                )
                return cookies
        except Exception as exc:
            self.logger.debug(f"Could not reload credentials.json: {exc}")
        return None

    # ------------------------------------------------------------------
    # Context manager support
    # ------------------------------------------------------------------

    def __enter__(self):
        self.initialize()
        return self

    def __exit__(self, *_):
        self.close()
